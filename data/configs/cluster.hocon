api_key {bootstrap_file = "/opt/emqx/etc/emqx/api_key.bootstrap"}
authentication = [
  {
    backend = http
    body {
      clientId = "${clientid}"
      password = "${password}"
      username = "${username}"
    }
    connect_timeout = 15s
    enable = true
    enable_pipelining = 100
    headers {
      accept = "application/json"
      cache-control = no-cache
      connection = keep-alive
      content-type = "application/json"
      keep-alive = "timeout=30, max=1000"
    }
    mechanism = password_based
    method = post
    pool_size = 8
    request_timeout = 5s
    ssl {
      ciphers = []
      depth = 10
      enable = false
      hibernate_after = 5s
      log_level = notice
      reuse_sessions = true
      secure_renegotiate = true
      verify = verify_peer
      versions = [tlsv1.3, tlsv1.2]
    }
    url = "http://iot-link-datahub/api/iot-link/auth/v1/das0001/auth"
  }
]
bridges {
  webhook {
    client_disconnected {
      connect_timeout = 15s
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      max_retries = 2
      method = post
      pool_size = 8
      pool_type = hash
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 1GB
        query_mode = async
        request_ttl = 45s
        start_after_created = true
        start_timeout = 5s
        worker_pool_size = 4
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [tlsv1.3, tlsv1.2]
      }
      url = "http://iot-link-datahub/api/iot-link/auth/v1/das0001/disconnected"
    }
  }
}
force_shutdown {
  enable = true
  max_heap_size = 1024MB
  max_message_queue_len = 1000000
}
gateway {
  coap {
    authentication {
      backend = http
      body {
        clientId = "${clientid}"
        password = "${password}"
        username = "${username}"
      }
      connect_timeout = 15s
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      mechanism = password_based
      method = post
      pool_size = 8
      request_timeout = 5s
      ssl {enable = false, verify = verify_peer}
      url = "http://iot-link-datahub/api/iot-link/auth/v1/das0001/auth"
    }
    connection_required = true
    enable = true
    enable_stats = true
    heartbeat = 30s
    listeners {
      udp {
        default {
          bind = "5683"
          max_conn_rate = 1000
          max_connections = 1024000
        }
      }
    }
    mountpoint = "sys/"
    notify_type = qos
    publish_qos = coap
    subscribe_qos = coap
  }
}
listeners {
  ssl {
    default {
      acceptors = 16
      access_rules = ["allow all"]
      authentication = []
      bind = "0.0.0.0:8883"
      enable = true
      enable_authn = true
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = 3s
      ssl_options {
        cacertfile = "${EMQX_ETC_DIR}/certs/cacert.pem"
        certfile = "${EMQX_ETC_DIR}/certs/cert.pem"
        ciphers = []
        client_renegotiation = true
        depth = 10
        enable_crl_check = false
        fail_if_no_peer_cert = false
        gc_after_handshake = false
        handshake_timeout = 15s
        hibernate_after = 5s
        honor_cipher_order = true
        keyfile = "${EMQX_ETC_DIR}/certs/key.pem"
        log_level = notice
        ocsp {
          enable_ocsp_stapling = false
          refresh_http_timeout = 15s
          refresh_interval = 5m
        }
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [tlsv1.3, tlsv1.2]
      }
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = 4KB
        high_watermark = 1MB
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = 15s
        send_timeout_close = true
      }
    }
  }
  tcp {
    default {
      acceptors = 16
      access_rules = ["allow all"]
      authentication = []
      bind = "0.0.0.0:1883"
      enable = true
      enable_authn = true
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = 3s
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = 4KB
        high_watermark = 1MB
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = 15s
        send_timeout_close = true
      }
    }
  }
  ws {
    default {
      acceptors = 16
      access_rules = ["allow all"]
      authentication = []
      bind = "0.0.0.0:8083"
      enable = true
      enable_authn = true
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = 3s
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = 4KB
        high_watermark = 1MB
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = 15s
        send_timeout_close = true
      }
      websocket {
        allow_origin_absence = true
        check_origin_enable = false
        check_origins = "http://localhost:18083, http://127.0.0.1:18083"
        compress = false
        deflate_opts {
          client_context_takeover = takeover
          client_max_window_bits = 15
          mem_level = 8
          server_context_takeover = takeover
          server_max_window_bits = 15
          strategy = default
        }
        fail_if_no_subprotocol = true
        idle_timeout = 7200s
        max_frame_size = infinity
        mqtt_path = "/mqtt"
        mqtt_piggyback = multiple
        proxy_address_header = x-forwarded-for
        proxy_port_header = x-forwarded-port
        supported_subprotocols = "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5"
      }
    }
  }
  wss {
    default {
      acceptors = 16
      access_rules = ["allow all"]
      authentication = []
      bind = "0.0.0.0:8084"
      enable = true
      enable_authn = true
      max_connections = infinity
      mountpoint = ""
      proxy_protocol = false
      proxy_protocol_timeout = 3s
      ssl_options {
        cacertfile = "${EMQX_ETC_DIR}/certs/cacert.pem"
        certfile = "${EMQX_ETC_DIR}/certs/cert.pem"
        ciphers = []
        client_renegotiation = true
        depth = 10
        fail_if_no_peer_cert = false
        handshake_timeout = 15s
        hibernate_after = 5s
        honor_cipher_order = true
        keyfile = "${EMQX_ETC_DIR}/certs/key.pem"
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tcp_options {
        active_n = 100
        backlog = 1024
        buffer = 4KB
        high_watermark = 1MB
        keepalive = none
        nodelay = true
        reuseaddr = true
        send_timeout = 15s
        send_timeout_close = true
      }
      websocket {
        allow_origin_absence = true
        check_origin_enable = false
        check_origins = "http://localhost:18083, http://127.0.0.1:18083"
        compress = false
        deflate_opts {
          client_context_takeover = takeover
          client_max_window_bits = 15
          mem_level = 8
          server_context_takeover = takeover
          server_max_window_bits = 15
          strategy = default
        }
        fail_if_no_subprotocol = true
        idle_timeout = 7200s
        max_frame_size = infinity
        mqtt_path = "/mqtt"
        mqtt_piggyback = multiple
        proxy_address_header = x-forwarded-for
        proxy_port_header = x-forwarded-port
        supported_subprotocols = "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5"
      }
    }
  }
}
mqtt {
  await_rel_timeout = 300s
  exclusive_subscription = false
  idle_timeout = 15s
  ignore_loop_deliver = false
  keepalive_multiplier = 1.5
  max_awaiting_rel = 100
  max_clientid_len = 65535
  max_inflight = 32
  max_mqueue_len = 1000
  max_packet_size = 1MB
  max_qos_allowed = 2
  max_subscriptions = infinity
  max_topic_alias = 65535
  max_topic_levels = 128
  mqueue_default_priority = lowest
  mqueue_priorities = disabled
  mqueue_store_qos0 = true
  peer_cert_as_clientid = disabled
  peer_cert_as_username = pem
  response_information = ""
  retain_available = true
  retry_interval = 30s
  server_keepalive = disabled
  session_expiry_interval = 2h
  shared_subscription = true
  shared_subscription_strategy = round_robin
  strict_mode = false
  upgrade_qos = false
  use_username_as_clientid = false
  wildcard_subscription = true
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = 10s
  rules {
    rule_disconnected {
      actions = ["webhook:client_disconnected"]
      description = ""
      metadata {created_at = 1698629194368}
      sql = "SELECT\n clientid,\n username,\n reason,\n disconnected_at,\n node\nFROM\n \"$events/client_disconnected\"\n"
    }
  }
}